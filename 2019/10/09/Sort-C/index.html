<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="Sort@C"><meta name="keywords" content="Sort,C"><meta name="author" content="𝓣𝓪𝓭𝓶"><meta name="copyright" content="𝓣𝓪𝓭𝓶"><title>Sort@C | 𝓣𝓪𝓭𝓶's Blog</title><link rel="shortcut icon" href="/my.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.0/css/all.min.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?837ab5c6a751430eeba265f36e622b79";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject=g,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script",0,"ga"),ga("create","UA-156561044-1","auto"),ga("send","pageview")</script><meta name="google-site-verification" content="4sNQ8r3e8C-DeXTBdbDP38MgpMP8Rw5pvHy2z4-z9ZY"><script>var GLOBAL_CONFIG={root:"/",copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"}}</script><meta name="generator" content="Hexo 4.2.1"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#常用排序-冒泡排序"><span class="toc-number">1.</span> <span class="toc-text">常用排序-冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#先来看一个乱序数组"><span class="toc-number">2.</span> <span class="toc-text">先来看一个乱序数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结果"><span class="toc-number">3.</span> <span class="toc-text">结果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#源代码-C"><span class="toc-number">4.</span> <span class="toc-text">源代码@C</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://i.loli.net/2019/11/24/Tj4hPoFKgXJE7xW.jpg"></div><div class="author-info__name text-center">𝓣𝓪𝓭𝓶</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://liuhongwei3.github.io">Follow me ≧◇≦</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">31</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">35</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">11</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://liuhongwei3.github.io">𝓣𝓪𝓭𝓶</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(https://i.loli.net/2019/10/09/tjJ5Ub4z1VNLI2B.png)"><div id="page-header"> <span class="pull-left"><a id="site-name" href="/">𝓣𝓪𝓭𝓶's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i> <span class="pull-right menus"><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/player">Player</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">Sort@C</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-10-09</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><div class="post-meta-wordcount"><span>Word count:</span> <span class="word-count">2.5k</span><span class="post-meta__separator">|</span><span>Reading time: 13 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><!DOCTYPE html><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><div id="aplayer"></div><script type="text/javascript" src="/js/aplayer.js"></script><div class="article-container" id="post-content"><h2 id="常用排序-冒泡排序"><a href="#常用排序-冒泡排序" class="headerlink" title="常用排序-冒泡排序"></a>常用排序-冒泡排序</h2><p><img src="https://i.loli.net/2019/10/09/rFvCVMUbdAHwm9l.gif" alt="冒泡排序演示"></p><p>时间复杂度： O(n) – O(n^2)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#define ARR_LEN 510</span></span><br><span class="line">void bubbleSort(int arr[],int len)&#123;</span><br><span class="line">    int temp=0;</span><br><span class="line">    <span class="keyword">for</span>(int i=0; i&lt;len-1; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(int j=0; j&lt;len-1-i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+1])&#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+1];</span><br><span class="line">                arr[j+1] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">main</span></span> () &#123;</span><br><span class="line">    int i=0,len,arr[ARR_LEN];</span><br><span class="line">    scanf(<span class="string">"%d"</span>,&amp;len);</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=len-1)&#123;</span><br><span class="line">        scanf(<span class="string">"%d"</span>,&amp;arr[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    bubbleSort(arr, len);</span><br><span class="line">    <span class="keyword">for</span>(int j=0; j&lt;len; j++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="先来看一个乱序数组"><a href="#先来看一个乱序数组" class="headerlink" title="先来看一个乱序数组"></a>先来看一个乱序数组</h2><p>23 45 12 20 0 1 4 3 2 6 5 9 34 99 66</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">* * * * 排序操作 * * * *</span><br><span class="line">请输入待排序序列:</span><br><span class="line"> 23 45 12 20  0  1  4  3  2  6  5  9 34 99 66 d</span><br><span class="line"></span><br><span class="line">希尔排序:</span><br><span class="line"></span><br><span class="line">第1趟希尔排序,增量dlta=7,排序结果为:</span><br><span class="line">  3  2  6  5  0  1  4 23 45 12 20  9 34 99 66</span><br><span class="line">第2趟希尔排序,增量dlta=3,排序结果为:</span><br><span class="line">  3  0  1  4  2  6  5 20  9 12 23 45 34 99 66</span><br><span class="line">第3趟希尔排序,增量dlta=1,排序结果为:</span><br><span class="line">  0  1  2  3  4  5  6  9 12 20 23 34 45 66 99</span><br><span class="line">希尔排序最终排序序列</span><br><span class="line">  0  1  2  3  4  5  6  9 12 20 23 34 45 66 99</span><br><span class="line">直接插入排序:</span><br><span class="line">  0  1  2  3  4  5  6  9 12 20 23 34 45 66 99</span><br><span class="line">冒泡排序:</span><br><span class="line">  0  1  2  3  4  5  6  9 12 20 23 34 45 66 99</span><br><span class="line">简单选择排序:</span><br><span class="line">  0  1  2  3  4  5  6  9 12 20 23 34 45 66 99</span><br><span class="line">快速排序:</span><br><span class="line"></span><br><span class="line">这是第1次划分，枢轴值为：0</span><br><span class="line">[0] 1 2 3 4 5 6 9 12 20 23 34 45 66 99</span><br><span class="line">这是第2次划分，枢轴值为：1</span><br><span class="line">[1] 2 3 4 5 6 9 12 20 23 34 45 66 99</span><br><span class="line">这是第3次划分，枢轴值为：2</span><br><span class="line">[2] 3 4 5 6 9 12 20 23 34 45 66 99 </span><br><span class="line">这是第4次划分，枢轴值为：3</span><br><span class="line">[3] 4 5 6 9 12 20 23 34 45 66 99</span><br><span class="line">这是第5次划分，枢轴值为：4</span><br><span class="line">[4] 5 6 9 12 20 23 34 45 66 99 </span><br><span class="line">这是第6次划分，枢轴值为：5</span><br><span class="line">[5] 6 9 12 20 23 34 45 66 99</span><br><span class="line">这是第7次划分，枢轴值为：6</span><br><span class="line">[6] 9 12 20 23 34 45 66 99</span><br><span class="line">这是第8次划分，枢轴值为：9</span><br><span class="line">[9] 12 20 23 34 45 66 99 </span><br><span class="line">这是第9次划分，枢轴值为：12</span><br><span class="line">[12] 20 23 34 45 66 99</span><br><span class="line">这是第10次划分，枢轴值为：20</span><br><span class="line">[20] 23 34 45 66 99</span><br><span class="line">这是第11次划分，枢轴值为：23</span><br><span class="line">[23] 34 45 66 99</span><br><span class="line">这是第12次划分，枢轴值为：34</span><br><span class="line">[34] 45 66 99</span><br><span class="line">这是第13次划分，枢轴值为：45</span><br><span class="line">[45] 66 99</span><br><span class="line">这是第14次划分，枢轴值为：66</span><br><span class="line">[66] 99</span><br><span class="line">快速排序最终排序序列:</span><br><span class="line">  0  1  2  3  4  5  6  9 12 20 23 34 45 66 99</span><br><span class="line">堆排序:</span><br><span class="line"></span><br><span class="line">建立的初始堆:</span><br><span class="line"> 99 23 66 12 20 45  6  9  3  1  4 34  5  2  0</span><br><span class="line">第1次排序:</span><br><span class="line"> 66 23 45 12 20 34  6  9  3  1  4  0  5  2 99</span><br><span class="line">第2次排序:</span><br><span class="line"> 45 23 34 12 20  5  6  9  3  1  4  0  2 66 99</span><br><span class="line">第3次排序:</span><br><span class="line"> 34 23  6 12 20  5  2  9  3  1  4  0 45 66 99</span><br><span class="line">第4次排序:</span><br><span class="line"> 23 20  6 12  4  5  2  9  3  1  0 34 45 66 99</span><br><span class="line">第5次排序:</span><br><span class="line"> 20 12  6  9  4  5  2  0  3  1 23 34 45 66 99</span><br><span class="line">第6次排序:</span><br><span class="line"> 12  9  6  3  4  5  2  0  1 20 23 34 45 66 99</span><br><span class="line">第7次排序:</span><br><span class="line">  9  4  6  3  1  5  2  0 12 20 23 34 45 66 99</span><br><span class="line">第8次排序:</span><br><span class="line">  6  4  5  3  1  0  2  9 12 20 23 34 45 66 99</span><br><span class="line">第9次排序:</span><br><span class="line">  5  4  2  3  1  0  6  9 12 20 23 34 45 66 99</span><br><span class="line">第10次排序:</span><br><span class="line">  4  3  2  0  1  5  6  9 12 20 23 34 45 66 99</span><br><span class="line">第11次排序:</span><br><span class="line">  3  1  2  0  4  5  6  9 12 20 23 34 45 66 99</span><br><span class="line">第12次排序:</span><br><span class="line">  2  1  0  3  4  5  6  9 12 20 23 34 45 66 99</span><br><span class="line">第13次排序:</span><br><span class="line">  1  0  2  3  4  5  6  9 12 20 23 34 45 66 99</span><br><span class="line">第14次排序:</span><br><span class="line">  0  1  2  3  4  5  6  9 12 20 23 34 45 66 99</span><br><span class="line"></span><br><span class="line">堆排序最终排序结果:</span><br><span class="line">  0  1  2  3  4  5  6  9 12 20 23 34 45 66 99</span><br><span class="line">归并排序:</span><br><span class="line"></span><br><span class="line">这是第1次归并,temp[0,1],m=0:</span><br><span class="line"> 49 65 97 76 13 27 49 38</span><br><span class="line">这是第2次归并,temp[2,3],m=2:</span><br><span class="line"> 49 65 97 76 13 27 49 38</span><br><span class="line">这是第3次归并,temp[0,3],m=1:</span><br><span class="line"> 49 65 97 76 13 27 49 38</span><br><span class="line">这是第4次归并,temp[4,5],m=4:</span><br><span class="line"> 49 65 97 13 76 27 49 38</span><br><span class="line">这是第5次归并,temp[6,7],m=6:</span><br><span class="line"> 49 65 97 13 76 27 49 38</span><br><span class="line">这是第6次归并,temp[4,7],m=5:</span><br><span class="line"> 49 65 97 13 27 49 76 38</span><br><span class="line">这是第7次归并,temp[0,7],m=3:</span><br><span class="line"> 27 38 49 49 65 76 97 13</span><br><span class="line">归并排序最终排序序列:</span><br><span class="line">13 27 38 49 49 65 76 97</span><br></pre></td></tr></table></figure><h2 id="源代码-C"><a href="#源代码-C" class="headerlink" title="源代码@C"></a>源代码@C</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#define MAX 50</span></span><br><span class="line">int <span class="built_in">times</span>;/*全局变量，用于查看统计快排时次数*/</span><br><span class="line">int time;</span><br><span class="line">void createList(int list[], int *n);/*创建待排序列*/</span><br><span class="line">void printList(int list[], int n);/*打印排序后序列*/</span><br><span class="line">void insertSort(int list[], int n);/*直接插入排序*/</span><br><span class="line">void bubbleSort(int list[], int n); /*冒泡排序*/</span><br><span class="line">void selectSort(int list[], int n); /*简单选择排序*/</span><br><span class="line">void QuickSort(int list[],int n);</span><br><span class="line">void QSort(int list[], int low, int high);</span><br><span class="line">int Partition(int list[],int low,int high); 	/*一次快速分区过程*/</span><br><span class="line">void ShellSort(int list[],int dlta[],int t,int n);</span><br><span class="line">void Shellinsert(int list[],int dk,int n);/*一趟希尔排序*/</span><br><span class="line">void createdlta(int n,int dlta[],int *t);/*构建增量序列*/</span><br><span class="line">void heapAdjust(int list[], int u, int v); /*堆调整*/</span><br><span class="line">void heapSort(int list[], int n); /*堆排序*/</span><br><span class="line">void MSort(int SR[],int TR[],int low,int high);//归并排序</span><br><span class="line">void Merge(int temp[],int list[],int low,int m,int high);</span><br><span class="line"></span><br><span class="line">void createList(int list[], int *n)</span><br><span class="line">&#123;</span><br><span class="line">    int i=1,a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入待排序序列:\n"</span>);</span><br><span class="line">    <span class="keyword">while</span>(scanf(<span class="string">"%d"</span>,&amp;a)==1)</span><br><span class="line">    &#123;</span><br><span class="line">        list[i]=a;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    *n=i-1;</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br><span class="line">void printList(int list[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i=1;</span><br><span class="line">    <span class="keyword">for</span>(i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%3d"</span>,list[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void insertSort(int list[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n直接插入排序:\n"</span>);</span><br><span class="line">    int i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=2;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        list[0]=list[i];</span><br><span class="line">        j=i-1;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;0&amp;&amp;list[0]&lt;list[j])</span><br><span class="line">        &#123;</span><br><span class="line">            list[j+1]=list[j];</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        list[j+1]=list[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void bubbleSort(int list[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n冒泡排序:\n"</span>);</span><br><span class="line">    int i=1,j,t,flag=1;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;n&amp;&amp;flag;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag=0;</span><br><span class="line">        <span class="keyword">for</span>(j=1;j&lt;n-i;j++)</span><br><span class="line">            <span class="keyword">if</span>(list[j]&gt;list[j+1])</span><br><span class="line">            &#123;</span><br><span class="line">                t=list[j];</span><br><span class="line">                list[j]=list[j+1];</span><br><span class="line">                list[j+1]=t;</span><br><span class="line">                flag=1;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void selectSort(int list[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n简单选择排序:\n"</span>);</span><br><span class="line">    int i,j,k,temp;</span><br><span class="line">    <span class="keyword">for</span>(i=1;i&lt;n-1;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        k=i;</span><br><span class="line">        <span class="keyword">for</span>(j=i;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(list[j]&lt;list[k])</span><br><span class="line">                k=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=k)</span><br><span class="line">        &#123;</span><br><span class="line">            temp=list[i];</span><br><span class="line">            list[i]=list[k];</span><br><span class="line">            list[k]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void ShellSort(int slist[],int dlta[],int t,int n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n希尔排序:\n"</span>);</span><br><span class="line">    int i,k;</span><br><span class="line">    <span class="keyword">for</span>(k=0;k&lt;t;++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n第%d趟希尔排序,增量dlta=%d,排序结果为:\n"</span>,k+1,dlta[k]);</span><br><span class="line">        Shellinsert(slist,dlta[k],n);</span><br><span class="line">        printList(slist,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void Shellinsert(int list[],int dk,int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=dk+1;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(list[i]&lt;list[i-dk])</span><br><span class="line">        &#123;</span><br><span class="line">            list[0]=list[i];</span><br><span class="line">            <span class="keyword">for</span>(j=i-dk;j&gt;0&amp;&amp;list[0]&lt;list[j];j-=dk)</span><br><span class="line">                list[j+dk]=list[j];</span><br><span class="line">            list[j+dk]=list[0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void createdlta(int n,int dlta[],int *t)</span><br><span class="line">&#123;</span><br><span class="line">    int i=0;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;1)</span><br><span class="line">    &#123;</span><br><span class="line">        n/=2;</span><br><span class="line">        <span class="keyword">if</span>(n%2==1||n==2)</span><br><span class="line">            dlta[i]=n;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dlta[i]=n+1;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    *t=i;</span><br><span class="line">&#125;</span><br><span class="line">void QSort(int list[],int low,int high)</span><br><span class="line">&#123;</span><br><span class="line">    int pivotloc,i,pivotkey;</span><br><span class="line">    pivotkey=list[low];</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n这是第%d次划分，枢轴值为：%d\n"</span>,++<span class="built_in">times</span>,pivotkey);</span><br><span class="line">        pivotloc=Partition(list,low,high);</span><br><span class="line">        <span class="keyword">for</span>(i=low;i&lt;=high;i++)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span>(list[i]==pivotkey&amp;&amp;i==pivotloc)</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">"[%d] "</span>,list[i]);</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">"%d "</span>,list[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        QSort(list,low,pivotloc-1);</span><br><span class="line">        QSort(list,pivotloc+1,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void QuickSort(int list[],int n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n快速排序:\n"</span>);</span><br><span class="line">    QSort(list,1,n);</span><br><span class="line">&#125;</span><br><span class="line">int Partition(int list[],int low,int high)</span><br><span class="line">&#123;</span><br><span class="line">    int pivotkey;</span><br><span class="line">    list[0]=list[low];</span><br><span class="line">    pivotkey=list[low];</span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;list[high]&gt;=pivotkey)</span><br><span class="line">            --high;</span><br><span class="line">        list[low]=list[high];</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;list[low]&lt;=pivotkey)</span><br><span class="line">            ++low;</span><br><span class="line">        list[high]=list[low];</span><br><span class="line">    &#125;</span><br><span class="line">    list[low]=list[0];</span><br><span class="line">    <span class="built_in">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line">void heapAdjust(int list[],int u,int v)</span><br><span class="line">&#123;</span><br><span class="line">    int i=u,j,temp=list[i];</span><br><span class="line">    j=2*i;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;v&amp;&amp;list[j]&lt;list[j+1])</span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">if</span>(temp&lt;list[j])</span><br><span class="line">        &#123;</span><br><span class="line">            list[i]=list[j];</span><br><span class="line">            i=j;</span><br><span class="line">            j=2*i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    list[i]=temp;</span><br><span class="line">&#125;</span><br><span class="line">void heapSort(int list[],int n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n堆排序:\n"</span>);</span><br><span class="line">    int i=0,count=1;</span><br><span class="line">    <span class="keyword">for</span>(i=n/2;i&gt;0;i--)</span><br><span class="line">        heapAdjust(list,i,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n建立的初始堆:\n"</span>);</span><br><span class="line">    printList(list,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=n;i&gt;1;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        list[0]=list[1];</span><br><span class="line">        list[1]=list[i];</span><br><span class="line">        list[i]=list[0];</span><br><span class="line">        heapAdjust(list,1,i-1);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"第%d次排序:\n"</span>,count++);</span><br><span class="line">        printList(list,n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*void MSort(int SR[],int TR[],int low,int high)</span><br><span class="line">&#123;</span><br><span class="line">    int m;</span><br><span class="line">    int temp[MAX];</span><br><span class="line">    <span class="keyword">if</span>(low==high)</span><br><span class="line">        TR[low]=SR[low];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m=(low+high)/2;</span><br><span class="line">        MSort(SR,temp,low,m);</span><br><span class="line">        MSort(SR,temp,m+1,high);</span><br><span class="line">        Merge(temp,TR,low,m,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void Merge(int temp[],int list[],int low,int m,int high)</span><br><span class="line">&#123;</span><br><span class="line">    int j,k,i=low;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n这是第%d次归并,temp[%d,%d],m=%d:\n"</span>,++time,low,high,m);</span><br><span class="line">    <span class="keyword">for</span>(j=m+1,k=i;i&lt;=m&amp;&amp;j&lt;=high;++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(temp[i]&lt;temp[j])</span><br><span class="line">            list[k]=temp[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            list[k]=temp[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=m)</span><br><span class="line">        list[k++]=temp[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high)</span><br><span class="line">        list[k++]=temp[j++];</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">void Merge(int sourceArr[],int tempArr[], int startIndex, int midIndex, int endIndex)</span><br><span class="line">&#123;</span><br><span class="line">    int i = startIndex, j=midIndex+1, k = startIndex;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n这是第%d次归并,temp[%d,%d],m=%d:\n"</span>,++time,startIndex,endIndex,midIndex);</span><br><span class="line">    <span class="keyword">while</span>(i!=midIndex+1 &amp;&amp; j!=endIndex+1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sourceArr[i] &gt; sourceArr[j])</span><br><span class="line">            tempArr[k++] = sourceArr[j++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tempArr[k++] = sourceArr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i != midIndex+1)</span><br><span class="line">        tempArr[k++] = sourceArr[i++];</span><br><span class="line">    <span class="keyword">while</span>(j != endIndex+1)</span><br><span class="line">        tempArr[k++] = sourceArr[j++];</span><br><span class="line">    <span class="keyword">for</span>(i=startIndex; i&lt;=endIndex; i++)</span><br><span class="line">        sourceArr[i] = tempArr[i];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">//内部使用递归</span><br><span class="line">void MergeSort(int sourceArr[], int tempArr[], int startIndex, int endIndex)</span><br><span class="line">&#123;</span><br><span class="line">    int midIndex;</span><br><span class="line">    <span class="keyword">if</span>(startIndex &lt; endIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        midIndex = (startIndex +endIndex)/ 2;//避免溢出int</span><br><span class="line">        MergeSort(sourceArr, tempArr, startIndex, midIndex);</span><br><span class="line">        MergeSort(sourceArr, tempArr, midIndex+1, endIndex);</span><br><span class="line">        Merge(sourceArr, tempArr, startIndex, midIndex, endIndex);</span><br><span class="line">        printList(sourceArr,8);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n* * * * 排序操作 * * * *\n"</span>);</span><br><span class="line">    int list[MAX],length,t,dlta[MAX],temp[MAX];</span><br><span class="line">    createList(list,&amp;length);</span><br><span class="line">    createdlta(length,dlta,&amp;t);</span><br><span class="line">    ShellSort(list,dlta,t,length);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n希尔排序最终排序序列\n"</span>);</span><br><span class="line">    printList(list,length);</span><br><span class="line">    insertSort(list,length);</span><br><span class="line">    printList(list,length);</span><br><span class="line">    bubbleSort(list,length);</span><br><span class="line">    printList(list,length);</span><br><span class="line">    selectSort(list,length);</span><br><span class="line">    printList(list,length);</span><br><span class="line">    QuickSort(list,length);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n快速排序最终排序序列:\n"</span>);</span><br><span class="line">    printList(list,length);</span><br><span class="line">    heapSort(list,length);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n堆排序最终排序结果:\n"</span>);</span><br><span class="line">    printList(list,length);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n归并排序:\n"</span>);</span><br><span class="line">    int a[8]=&#123;49,38,65,97,76,13,27,49&#125;;</span><br><span class="line">    MergeSort(a, temp, 0, 7);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n归并排序最终排序序列:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(int i=0;i&lt;8;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>放一个更加生动详细的网页：<a href="https://visualgo.net/zh" target="_blank" rel="noopener">https://visualgo.net/zh</a></p><blockquote><p>再次复习一下排序算法，加深印象！</p></blockquote></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author:</span> <span class="post-copyright-info"><a href="mailto:undefined">𝓣𝓪𝓭𝓶</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link:</span> <span class="post-copyright-info"><a href="https://liuhongwei3.github.io/2019/10/09/Sort-C/">https://liuhongwei3.github.io/2019/10/09/Sort-C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice:</span> <span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Sort/">Sort</a><a class="post-meta__tags" href="/tags/C/">C</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/11/16/GitStudy/"><i class="fa fa-chevron-left"></i> <span>gitStudy</span></a></div><div class="next-post pull-right"><a href="/2019/10/08/css-doodle/"><span>css3-doodle</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image:url(https://i.loli.net/2019/10/09/tjJ5Ub4z1VNLI2B.png)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 &nbsp;<i class="fa fa-heart" aria-hidden="true" id="myheart"></i>&nbsp; <a href="https://liuhongwei3.github.io/" target="_blank">𝓣𝓪𝓭𝓶</a></div><div class="framework-info"><span>Driven -</span> <a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme -</span> <a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="footer_custom_text">Hi,Welcome to my blog,maybe you can find more!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-eye"></i>本篇已阅读次数：<span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/heart.js?version=1.7.0"></script><script src="/js/typed.js?version=1.7.0"></script><script src="/js/google.js?version=1.7.0"></script><script>/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"),$("#top-container").addClass("is-mobile"))</script></body></html>