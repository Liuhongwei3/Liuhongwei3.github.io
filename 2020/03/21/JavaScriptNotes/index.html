<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="JavaScriptNotes"><meta name="keywords" content="JavaScript"><meta name="author" content="𝓣𝓪𝓭𝓶"><meta name="copyright" content="𝓣𝓪𝓭𝓶"><title>JavaScriptNotes | 𝓣𝓪𝓭𝓶's Blog</title><link rel="shortcut icon" href="/my.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.0/css/all.min.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?837ab5c6a751430eeba265f36e622b79";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>!function(e,a,t,n,g,c,o){e.GoogleAnalyticsObject=g,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,c=a.createElement(t),o=a.getElementsByTagName(t)[0],c.async=1,c.src="https://www.google-analytics.com/analytics.js",o.parentNode.insertBefore(c,o)}(window,document,"script",0,"ga"),ga("create","UA-156561044-1","auto"),ga("send","pageview")</script><meta name="google-site-verification" content="4sNQ8r3e8C-DeXTBdbDP38MgpMP8Rw5pvHy2z4-z9ZY"><script>var GLOBAL_CONFIG={root:"/",copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"}}</script><meta name="generator" content="Hexo 4.2.1"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript-简介"><span class="toc-number">1.</span> <span class="toc-text">JavaScript 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#历史"><span class="toc-number">1.1.</span> <span class="toc-text">历史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#定义"><span class="toc-number">1.2.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组成"><span class="toc-number">1.3.</span> <span class="toc-text">组成</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTML-中应用-JavaScript"><span class="toc-number">2.</span> <span class="toc-text">HTML 中应用 JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Hello-World"><span class="toc-number">2.1.</span> <span class="toc-text">Hello World</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#放置位置"><span class="toc-number">2.2.</span> <span class="toc-text">放置位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#defer-amp-amp-async"><span class="toc-number">2.3.</span> <span class="toc-text">defer &amp;&amp; async</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Explanation"><span class="toc-number">2.3.1.</span> <span class="toc-text">Explanation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Useage"><span class="toc-number">2.3.2.</span> <span class="toc-text">Useage</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#noscript"><span class="toc-number">2.4.</span> <span class="toc-text">noscript</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基本语法"><span class="toc-number">3.</span> <span class="toc-text">基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型"><span class="toc-number">3.1.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量"><span class="toc-number">3.2.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常量"><span class="toc-number">3.3.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Number"><span class="toc-number">3.4.</span> <span class="toc-text">Number</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String"><span class="toc-number">3.5.</span> <span class="toc-text">String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Null-amp-amp-Undefined"><span class="toc-number">3.6.</span> <span class="toc-text">Null &amp;&amp; Undefined</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Array"><span class="toc-number">3.7.</span> <span class="toc-text">Array</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本知识"><span class="toc-number">3.7.1.</span> <span class="toc-text">基本知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型检测"><span class="toc-number">3.7.2.</span> <span class="toc-text">类型检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈方法-LIFO"><span class="toc-number">3.7.3.</span> <span class="toc-text">栈方法(LIFO)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#队列方法-FIFO"><span class="toc-number">3.7.4.</span> <span class="toc-text">队列方法(FIFO)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重排序"><span class="toc-number">3.7.5.</span> <span class="toc-text">重排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#操作方法"><span class="toc-number">3.7.6.</span> <span class="toc-text">操作方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查找项的位置"><span class="toc-number">3.7.7.</span> <span class="toc-text">查找项的位置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object"><span class="toc-number">3.8.</span> <span class="toc-text">Object</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本知识-1"><span class="toc-number">3.8.1.</span> <span class="toc-text">基本知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#属性"><span class="toc-number">3.8.2.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定义属性"><span class="toc-number">3.8.3.</span> <span class="toc-text">定义属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-defineProperty"><span class="toc-number">3.8.3.1.</span> <span class="toc-text">Object.defineProperty</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-defineProperties"><span class="toc-number">3.8.3.2.</span> <span class="toc-text">Object.defineProperties</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#读取属性"><span class="toc-number">3.8.4.</span> <span class="toc-text">读取属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-getOwnPropertyDescriptor"><span class="toc-number">3.8.4.1.</span> <span class="toc-text">Object.getOwnPropertyDescriptor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-getOwnPropertyDescriptors"><span class="toc-number">3.8.4.2.</span> <span class="toc-text">Object.getOwnPropertyDescriptors</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Create-Object"><span class="toc-number">3.8.5.</span> <span class="toc-text">Create Object</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#工厂模式"><span class="toc-number">3.8.5.1.</span> <span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#构造函数模式"><span class="toc-number">3.8.5.2.</span> <span class="toc-text">构造函数模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#原型模式"><span class="toc-number">3.8.5.3.</span> <span class="toc-text">原型模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#组合使用构造函数模式和原型模式"><span class="toc-number">3.8.5.4.</span> <span class="toc-text">组合使用构造函数模式和原型模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态原型模式"><span class="toc-number">3.8.5.5.</span> <span class="toc-text">动态原型模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#寄生构造函数模式"><span class="toc-number">3.8.5.6.</span> <span class="toc-text">寄生构造函数模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#稳妥构造函数模式"><span class="toc-number">3.8.5.7.</span> <span class="toc-text">稳妥构造函数模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Extends"><span class="toc-number">3.8.6.</span> <span class="toc-text">Extends</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#组合继承-常用"><span class="toc-number">3.8.6.1.</span> <span class="toc-text">组合继承(常用)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#原型式继承"><span class="toc-number">3.8.6.2.</span> <span class="toc-text">原型式继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#寄生式继承"><span class="toc-number">3.8.6.3.</span> <span class="toc-text">寄生式继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#寄生组合式继承-最理想"><span class="toc-number">3.8.6.4.</span> <span class="toc-text">寄生组合式继承(最理想)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类似数组的对象"><span class="toc-number">3.8.7.</span> <span class="toc-text">类似数组的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#More"><span class="toc-number">3.8.8.</span> <span class="toc-text">More</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Function"><span class="toc-number">3.9.</span> <span class="toc-text">Function</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Basic"><span class="toc-number">3.9.1.</span> <span class="toc-text">Basic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数作用域"><span class="toc-number">3.9.2.</span> <span class="toc-text">函数作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#闭包-重点"><span class="toc-number">3.9.3.</span> <span class="toc-text">闭包 (重点)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#立即调用的函数表达式（IIFE）"><span class="toc-number">3.9.4.</span> <span class="toc-text">立即调用的函数表达式（IIFE）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#eval-不常用，了解"><span class="toc-number">3.9.5.</span> <span class="toc-text">eval (不常用，了解)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typeof"><span class="toc-number">3.10.</span> <span class="toc-text">typeof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#instanceof"><span class="toc-number">3.11.</span> <span class="toc-text">instanceof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本结构体"><span class="toc-number">3.12.</span> <span class="toc-text">基本结构体</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RegExp"><span class="toc-number">4.</span> <span class="toc-text">RegExp</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#变量、作用域、内存"><span class="toc-number">5.</span> <span class="toc-text">变量、作用域、内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#复制变量值"><span class="toc-number">5.1.</span> <span class="toc-text">复制变量值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本类型"><span class="toc-number">5.1.1.</span> <span class="toc-text">基本类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#引用类型"><span class="toc-number">5.1.2.</span> <span class="toc-text">引用类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#传递参数"><span class="toc-number">5.2.</span> <span class="toc-text">传递参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型检测-1"><span class="toc-number">5.3.</span> <span class="toc-text">类型检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#执行环境及作用域"><span class="toc-number">5.4.</span> <span class="toc-text">执行环境及作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#没有块级作用域"><span class="toc-number">5.5.</span> <span class="toc-text">没有块级作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#垃圾回收"><span class="toc-number">5.6.</span> <span class="toc-text">垃圾回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解除引用"><span class="toc-number">5.7.</span> <span class="toc-text">解除引用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#引用类型-1"><span class="toc-number">6.</span> <span class="toc-text">引用类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-number">7.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://i.loli.net/2019/11/24/Tj4hPoFKgXJE7xW.jpg"></div><div class="author-info__name text-center">𝓣𝓪𝓭𝓶</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://liuhongwei3.github.io">Follow me ≧◇≦</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">31</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">35</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">11</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://liuhongwei3.github.io">𝓣𝓪𝓭𝓶</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(https://i.loli.net/2020/02/28/2OPSFfaL73QIizV.jpg)"><div id="page-header"> <span class="pull-left"><a id="site-name" href="/">𝓣𝓪𝓭𝓶's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i> <span class="pull-right menus"><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/player">Player</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">JavaScriptNotes</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-21</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/studyNotes/">studyNotes</a><div class="post-meta-wordcount"><span>Word count:</span> <span class="word-count">7.3k</span><span class="post-meta__separator">|</span><span>Reading time: 27 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><!DOCTYPE html><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><div id="aplayer"></div><script type="text/javascript" src="/js/aplayer.js"></script><div class="article-container" id="post-content"><h1 id="JavaScript-简介"><a href="#JavaScript-简介" class="headerlink" title="JavaScript 简介"></a>JavaScript 简介</h1><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><ul><li><p>Brendan Eich 10 days.</p></li><li><p>1995年诞生，为处理输入验证操作。(LiveScript–&gt;JavaScript)</p></li><li><p>1997年，JavaScript 1.1 提交至欧洲计算机制造商协会(ECMA)，并定义了 ECMAScript 新脚本语言标准。</p></li><li><p>……</p></li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>JavaScript 是一种<strong>轻量级</strong>的<strong>脚本语言</strong>。</p><p>JavaScript 是一种嵌入式（embedded）语言。本身提供的核心语法不算很多，只能用来做一些数学和逻辑运算。本身不提供任何与 I/O（输入/输出）相关的 API，都要靠宿主环境（host）提供，所以 JavaScript 只合适嵌入更大型的应用程序环境，去调用宿主环境提供的底层 API。</p><p>目前，已经嵌入 JavaScript 的宿主环境有多种，最常见的环境就是浏览器，另外还有服务器环境，也就是 Node 、Deno等等。</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul><li><p>核心 (ECMAScript)</p><ul><li><p>已经不断更新多次，到现在常用 ES5/ES6，直到如今更高版本。</p><table><thead><tr><th>1997年7月</th><th>ECMAScript 1.0</th></tr></thead><tbody><tr><td>1998年6月</td><td>ECMAScript 2.0</td></tr><tr><td>1999年12月</td><td>ECMAScript 3.0</td></tr><tr><td>2007年10月</td><td>ECMAScript 4.0</td></tr><tr><td>2009年12月</td><td>ECMAScript 5.0</td></tr><tr><td>2011年6月</td><td>ECMAscript 5.1</td></tr><tr><td>2015年6月</td><td>ECMAScript 6（2015）</td></tr></tbody></table></li></ul></li><li><p>文档对象模型 (DOM)</p><ul><li>Document Object Model——文档对象模型）是用来呈现以及与任意 HTML 或 XML文档交互的API。DOM 是载入到浏览器中的文档模型，以节点树的形式来表现文档，每个节点代表文档的构成部分（例如:页面元素、字符串或注释等等）；我们可以通过接口可以轻松的对节点进行添加、删除等操作。</li></ul></li><li><p>浏览器对象模型 (BOM)</p><ul><li>Browser Object Model: 提供与浏览器进行交互的方法和接口。其标准并没有确切的，会因不同浏览器而异。</li></ul></li></ul><h1 id="HTML-中应用-JavaScript"><a href="#HTML-中应用-JavaScript" class="headerlink" title="HTML 中应用 JavaScript"></a>HTML 中应用 JavaScript</h1><p>在HTML中以 <code>&lt;script&gt;&lt;/script&gt;</code> 标签内嵌，也可通过<code>src</code>来引入外部的一个<code>.js</code>文件.</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"hello Tadm~"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="放置位置"><a href="#放置位置" class="headerlink" title="放置位置"></a>放置位置</h2><blockquote><p>在这之前我们需要了解HTML页面加载渲染的过程：</p></blockquote><blockquote><ol><li>浏览器通过HTTP协议请求服务器，获取下载HMTL文档并开始从上到下解析，构建 DOM；</li><li>在构建 DOM 的过程中，如果遇到外联的样式声明和脚本声明，则暂停文档解析，下载样式文件和脚本文件；</li><li>样式文件下载完成后，构建 CSSDOM；脚本文件下载完成后，解释并执行，然后继续解析文档构建 DOM</li><li>完成文档解析后，将 DOM 和 CSSDOM进行关联和映射，最后将视图渲染到浏览器窗口。</li></ol></blockquote><ul><li>置于<code>&lt;head&gt;&lt;/head&gt;</code>标签中<ul><li>在加载页面前，需要先将所有的JS代码下载、解析、执行完，才会去编译页面内容。但会导致页面出现空白，因为代码解析执行是会有相应的时间，相当于处于等待状态。</li></ul></li><li>置于<code>&lt;body&gt;&lt;/body&gt;</code>标签中<ul><li>在页面代码前同样会出现在head标签中的问题；在页面代码后完美解决这个问题，当然也可以在<em>script</em>标签中添加<code>async</code>和<code>defer</code>关键字来指定其是异步加载的，可以先加载页面再去处理JS代码，但同时有<code>async</code>标记的则不会保证其执行顺序。</li></ul></li></ul><h2 id="defer-amp-amp-async"><a href="#defer-amp-amp-async" class="headerlink" title="defer &amp;&amp; async"></a>defer &amp;&amp; async</h2><h3 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h3><p><code>defer</code>：用于开启<strong>新的线程下载</strong>脚本文件，并使脚本在<strong>文档解析完成后</strong>执行。只适用于外联脚本，保证了彼此的先后顺序。<br><code>async</code>：HTML5新增属性，用于<strong>异步下载</strong>脚本文件，<strong>下载完毕立即解释执行</strong>代码。不能确保彼此的先后顺序，会在<code>load</code>事件之前执行。</p><p><img src="https://www.kirupa.com/html5/images/summary_200.png" alt="img"></p><h3 id="Useage"><a href="#Useage" class="headerlink" title="Useage"></a>Useage</h3><ol><li>将脚本引用放置在DOM下方，紧接在您的<code>&lt;/body&gt;</code>元素上方。</li><li>除非您要创建供他人使用的库，否则不要通过侦听 <strong>DOMContentLoaded</strong>或<strong>load</strong> 事件来使代码复杂化。相反，请参阅上一点。</li><li>使用 defer属性标记引用外部文件的脚本。</li><li>如果您的代码不依赖于加载DOM并作为对文档中其他脚本的准备工作的一部分来运行，则可以将此脚本放置在页面顶部，并 在其上设置async属性。</li></ol><h2 id="noscript"><a href="#noscript" class="headerlink" title="noscript"></a>noscript</h2><p>有时候我们需要提醒用户的浏览器暂不支持script，当然现在主流浏览器基本上都已经支持并丰富了很多操作和功能，但是我们需要知道知识点。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">noscript</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>您的浏览器暂不支持 JavaScript<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><blockquote><p> 涉及到的其他程序语言共同处不再陈述。</p></blockquote><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>Number</li><li>Boolean (true/false)</li><li>String</li><li>undefined (未定义)</li><li>null (空)</li><li>Object<ul><li>Object</li><li>Array</li><li>Function</li></ul></li><li>Symbol (ES6)</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><blockquote><p><code>变量名</code>，即标识符。大小写敏感，不能数字开头即可</p></blockquote><blockquote><p><code>var</code>存在变量提升（所有的变量的声明语句，都会被提升到代码的头部）（JavaScript 引擎的工作方式是：<strong>先解析代码，获取所有被声明的变量，然后再一行一行地运行</strong>）；而<code>let</code>则不会，只是在其作用域起效；同时也不能在同一作用域重复声明。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(n); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IIFE 写法</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 块级作用域写法</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">'tadm'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 foo 添加一个属性，可以成功</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br><span class="line">foo.prop <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 foo 指向另一个对象，就会报错</span></span><br><span class="line">foo = &#123;&#125;; <span class="comment">// TypeError: "foo" is read-only</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = [];</span><br><span class="line">a.push(<span class="string">'Hello'</span>); <span class="comment">// 可执行</span></span><br><span class="line">a.length = <span class="number">0</span>;    <span class="comment">// 可执行</span></span><br><span class="line">a = [<span class="string">'Dave'</span>];    <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	冻结对象，使得不能再添加新属性</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规模式时，下面一行不起作用；</span></span><br><span class="line"><span class="comment">// 严格模式时，该行会报错</span></span><br><span class="line"><span class="comment">// "use strict";</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><blockquote><p><code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于<strong>简单类型的数据</strong>（数值、字符串、布尔值），值就<strong>保存在变量指向的那个内存地址</strong>，因此等同于常量。但对于<strong>复合类型的数据</strong>（主要是对象和数组），变量指向的<strong>内存地址</strong>，保存的只是一个<strong>指向实际数据的指针</strong>，<code>const</code>只能<strong>保证这个指针是固定的</strong>（即总是指向另一个固定的地址），至于<strong>它指向的数据结构是不是可变的，就完全不能控制了</strong>。因此，将一个对象声明为常量必须非常小心。</p></blockquote><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><blockquote><p>JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此.</p></blockquote><p>上述换句话说：JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）；这样对于<strong>浮点数</strong>的计算是非常危险的，因为计算并不是非常准确。</p><ul><li><p>64 位浮点数</p><blockquote><ul><li>第 1 位：符号位，<code>0</code>表示正数，<code>1</code>表示负数</li><li>第 2 位到第 12 位（共 11 位）：指数部分</li><li>第 13 位到第64位（共 52 位）：小数部分（即有效数字）</li></ul></blockquote><blockquote><p>符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。</p></blockquote><blockquote><p>指数部分一共有11个二进制位，因此大小范围就是0-2047。IEEE 754 规定，如果指数部分的值在<strong>0-2047</strong>之间（不含两个端点），那么有效数字的第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字这时总是<code>1.xx...xx</code>的形式，其中<code>xx..xx</code>的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript 提供的有效数字最长为53个二进制位。</p></blockquote><blockquote><p>(-1)^符号位 * 1.xx…xx * 2^指数部分</p></blockquote></li></ul><blockquote><p>绝对值小于2的53次方的整数，即<code>-2^53</code>到<code>2^53</code>，JS都可以精确表示</p></blockquote><p><strong>表示范围</strong>：</p><p>​ <code>-Infinity</code>，<code>-0</code>，<code>0</code>，<code>2^-1023</code>（开区间） ~ <code>2^1024</code>，<code>Infinity</code></p><p><strong>进制</strong>：</p><ul><li>十进制：没有前导0的数值。</li><li>八进制：有前缀<code>0o</code>或<code>0O</code>的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。<ul><li>严格模式（”use strict”）无效，会使 JS 引擎抛出错误</li></ul></li><li>十六进制：有前缀<code>0x</code>或<code>0X</code>的数值。</li><li>二进制：有前缀<code>0b</code>或<code>0B</code>的数值。</li></ul><p><strong>parseInt():</strong></p><ul><li><p>将字符串转为整数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'hello1234ddd'</span>)</span><br><span class="line"><span class="literal">NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1234ddd'</span>)</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure></li><li><p>如果不是字符串时，则会先将其转换为字符串，再转为整数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">123</span>)	<span class="comment">//	parseInt(String(123))</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure></li><li><p>也可进行进制转换(返回十进制)：<code>parseInt(&#39;10&#39;,2) --&gt; 2</code>，如果输入了不包含当前进制的则会返回<code>NaN</code></p></li></ul><p><strong>parseFloat</strong>():</p><ul><li>将一个字符串转为浮点数</li><li>若字符串符合科学计数法，则会进行相应的转换</li></ul><p><strong>特殊值</strong>：</p><ul><li><p>+0（0）</p></li><li><p>-0</p></li><li><p>+Infinity （Infinity）(x/+0，Infinity/0，Infinity + Infinity ，Infinity * Infinity )</p></li><li><p>-Infinity (x/-0)</p></li><li><p>NaN (Not a Number)</p><ul><li>字符串解析成数字出错</li><li>某些不符合正常的函数运算结果（0/0）</li><li>0 * Infinity，Infinity - Infinity ，Infinity 、 Infinity</li><li>NaN === NaN —&gt; false</li><li>[NaN].indexOf(NaN) —&gt; -1 (indexOf 严格相等)</li></ul><blockquote><p><code>Infinity</code>与<code>NaN</code>比较，总是返回<code>false</code></p></blockquote><p><strong>isNaN</strong>(): 判断一个值是否为<code>NaN</code></p><ul><li>NaN –&gt; true</li><li>!Number –&gt; isNaN(Number(x))</li><li><strong>空数组</strong>和只有<strong>一个数值成员的数组</strong> –&gt; false</li></ul><p><strong>isFinite</strong>(): 返回一个布尔值，表示某个值是否为正常的数值。</p><p>​ 只有以下才为<code>false</code>:</p><ul><li>+-Infinity</li><li>NaN</li><li>undefined</li></ul></li></ul><p><strong>位运算符</strong>：</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><blockquote><p>零个或多个排在一起的字符，放在单引号或双引号之中；默认写在一行，如果需要多行，则需要行末添加反斜杠<code>\</code>（此时输出仍在一行内）</p></blockquote><blockquote><p>其 <code>length</code> 属性返回字符串长度，且不能被更改</p></blockquote><p>toString():</p><ul><li>将非字符串转换为字符串（为数值时可传入进制数）</li></ul><p><strong>反斜杠</strong></p><ul><li><p>转义</p></li><li><p>\HHH</p><p>反斜杠后面紧跟<strong>三个八进制数</strong>（<code>000</code>到<code>377</code>），代表一个字符。<code>HHH</code>对应该字符的 Unicode 码点，比如<code>\251</code>表示版权符号。显然，这种方法只能输出<strong>256</strong>种字符。</p></li><li><p>\xHH</p><p><code>\x</code>后面紧跟<strong>两个十六进制数</strong>（<code>00</code>到<code>FF</code>），代表一个字符。<code>HH</code>对应该字符的 Unicode 码点，比如<code>\xA9</code>表示版权符号。这种方法也只能输出<strong>256</strong>种字符。</p></li><li><p>\uXXXX</p><p><code>\u</code>后面紧跟<strong>四个十六进制数</strong>（<code>0000</code>到<code>FFFF</code>），代表一个字符。<code>XXXX</code>对应该字符的 Unicode 码点，比如<code>\u00A9</code>表示版权符号。</p></li></ul><blockquote><p>字符串可以被视为<strong>字符数组</strong>，因此可以使用数组的<strong>方括号运算符</strong>，用来返回<strong>某个位置的字符</strong>（位置编号从<code>0</code>开始）；但不能用于增删改操作。</p></blockquote><p><strong>字符集</strong>：</p><blockquote><p>JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。当然还允许直接在程序中使用 Unicode 码点表示字符，即将字符写成<code>\uxxxx</code>的形式，其中<code>xxxx</code>代表该字符的 Unicode 码点。</p></blockquote><blockquote><p>解析代码的时候，JavaScript 会自动识别一个字符是字面形式表示，还是 Unicode 形式表示。输出给用户的时候，所有字符都会转成字面形式。</p></blockquote><p>​ 字符内部存储：</p><pre><code>- 每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存</code></pre><p>​ 但是由于历史原因，初始设计时并未考虑到现在使用了如此多的字符！所以对于码点在<code>U+10000</code>到<code>U+10FFFF</code>之间的字符，JavaScript 总是认为它们是两个字符（<code>length</code>属性为2）。所以处理的时候，必须把这一点考虑在内；也就是说，JavaScript 返回的字符串长度可能是不正确的。</p><h2 id="Null-amp-amp-Undefined"><a href="#Null-amp-amp-Undefined" class="headerlink" title="Null &amp;&amp; Undefined"></a>Null &amp;&amp; Undefined</h2><ul><li><p><code>null</code> 表示空，即空对象指针</p></li><li><p><code>undefined</code> 表示未定义，一般是声明了变量但并未对其初始化，该变量则为<code>undefined</code>；派生自<code>null</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>		<span class="comment">//	"object"</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>		<span class="comment">//	true</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span>		<span class="comment">//	false</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><blockquote><p>一组值（任何类型）按次序排列（！排序），同C，JAVA等中的数组一样</p></blockquote><p>​ 注意：本质上也是一种<strong>特殊的对象</strong>（typeof [1,2] –&gt; “object”）</p><p>​ arr[1] —&gt; arr[‘1’] —&gt; 2</p><p>​ <code>length</code>属性是可写的:</p><ul><li>数组的数字键不需要连续，<code>length</code>属性的值总是比最大的那个整数键大<code>1</code>。另外，这也表明数组是一种动态的数据结构，可以随时增减数组的成员。</li><li>人为设置一个小于当前成员个数的值时，该数组的成员会自动减少到<code>length</code>设置的值（设置为0时则相当于清空数组）。</li><li>人为设置一个大于当前成员个数的值时，读取新增的位置数据时为<code>undefined</code></li></ul><blockquote><p> 如果数组的键名是添加超出范围的数值，该键名会自动转为字符串；同时通过方括号（[-1]）仍可以获得其值，但此时<code>length</code>还是为<code>0</code></p></blockquote><p><strong>in</strong>:</p><ul><li>返回Boolean，判断某个元素是否存在于数组中</li></ul><p><strong>for…in…</strong>:</p><ul><li><p><strong>遍历数组</strong>（但是会遍历他的<strong>所有键</strong>）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.foo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> a) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// foo</span></span><br></pre></td></tr></table></figure><p>以后通常使用<code>forEach</code>、<code>map</code>、<code>for...of...</code>、<code>reduce</code>、<code>reduceRight</code>……</p></li></ul><h3 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h3><p>判断一个变量是否为数组：</p><ul><li>x instanceof Array</li><li>Array.isArray(x)</li></ul><h3 id="栈方法-LIFO"><a href="#栈方法-LIFO" class="headerlink" title="栈方法(LIFO)"></a>栈方法(LIFO)</h3><ul><li>push(x, …) — 入栈并返回修改后数组的 length</li><li>pop() — （最后一项）出栈并返回被移除的项</li></ul><h3 id="队列方法-FIFO"><a href="#队列方法-FIFO" class="headerlink" title="队列方法(FIFO)"></a>队列方法(FIFO)</h3><ul><li>unshift(x, …) — 入队并返回 length</li><li>shift() — （第一项）出队并返回被移除的项</li></ul><h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><ul><li>x.sort()</li><li>x.reverse()</li></ul><h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><ul><li>x.concat(y,…)</li><li>x.slice(start, [end]) — 返回新数组且不会影响原数组</li><li>x.splice()<ul><li>x.splice(start, delNumber) — 从 start 开始删除 delNumber 项</li><li>x.splice(start, 0, insert1,….) — 从 start 开始插入 多项</li><li>x.splice(start, delNumber, insert1,…) — 从 start 开始删除 delNumber 项并插入多项，类似于替换效果</li></ul></li></ul><h3 id="查找项的位置"><a href="#查找项的位置" class="headerlink" title="查找项的位置"></a>查找项的位置</h3><ul><li>x.indexOf(item, [start]) — 从前往后</li><li>x.lastIndexOf(item, [start]) — 从后往前</li></ul><blockquote><p>从数组中查找第一个符合条件的，若找到返回其索引，否则返回 -1 且在查找时使用 ‘===’ 进行判断。</p></blockquote><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="基本知识-1"><a href="#基本知识-1" class="headerlink" title="基本知识"></a>基本知识</h3><p><img src="C:%5CUsers%5C28731%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200322201420824.png" alt="image-20200322201420824"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'tadm'</span>,</span><br><span class="line">    age: <span class="number">19</span>,</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'I\'m saying'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.name	<span class="comment">//	tadm</span></span><br><span class="line">obj.age		<span class="comment">//	19</span></span><br><span class="line">obj[<span class="string">'age'</span>]	<span class="comment">//	19</span></span><br><span class="line">obj.say()	<span class="comment">//	I'm saying</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	对象引用</span></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = o1;</span><br><span class="line"></span><br><span class="line">o1.a = <span class="number">1</span>;</span><br><span class="line">o2.a 	<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = o1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	取消引用，此时 o1,o2 不再指向同一个内存地址</span></span><br><span class="line">o1 = <span class="number">1</span>;</span><br><span class="line">o2 <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(obj)	<span class="comment">//	查看对象的所有自身可枚举属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.name		<span class="comment">//	删除对象本身的属性，不包括继承（原型链）的属性</span></span><br><span class="line"></span><br><span class="line"><span class="string">'toString'</span> <span class="keyword">in</span> obj	<span class="comment">//	true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ... in ...		<span class="comment">//	遍历对象所有可遍历的属性（自身+继承），但会跳过不可遍历的属性</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> s <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//	如果我们只需要遍历自身的属性，不遍历继承的属性</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="keyword">if</span> (person.hasOwnProperty(key)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义属性"><a href="#定义属性" class="headerlink" title="定义属性"></a>定义属性</h3><h4 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'Tadm'</span>,</span><br><span class="line">    age: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	object default value</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, age, &#123;</span><br><span class="line">    <span class="comment">//	能否通过 delete 删除属性来重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性</span></span><br><span class="line">    configurable: <span class="literal">true</span>,	</span><br><span class="line">    <span class="comment">//	能否枚举</span></span><br><span class="line">    Enumerable: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">//	能否修改属性的值</span></span><br><span class="line">    Writable: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">//	包含这个属性的数据值，读取写入的值保存在此处</span></span><br><span class="line">    Value: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="comment">//	读取属性时调用的函数</span></span><br><span class="line">    <span class="keyword">get</span>: undefined,</span><br><span class="line">    //	写入属性时调用的函数</span><br><span class="line">    <span class="keyword">set</span>: undefined</span><br><span class="line">&#125;)</span><br><span class="line">//	在单独使用 Object.defineProperty() 方法时默认值为 false</span><br></pre></td></tr></table></figure><blockquote><p>以上为 false 时，我们仍要操作时在非严格模式下会将其忽略，严格模式下抛出错误。而且，一旦(configurable)属性定义为不可配置，就不能再修改为可配置。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = &#123;</span><br><span class="line">    <span class="keyword">get</span>: function () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'I alway return this string,whatever you have assigned'</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function () &#123;</span><br><span class="line">        <span class="keyword">this</span>.myname = <span class="string">'this is my name string'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TestDefineSetAndGet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, <span class="string">'myproperty'</span>, pattern);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> TestDefineSetAndGet();</span><br><span class="line">instance.myproperty = <span class="string">'test'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 'I alway return this string,whatever you have assigned'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.myproperty);</span><br><span class="line"><span class="comment">// 'this is my name string'</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.myname);继承属性</span><br></pre></td></tr></table></figure><blockquote><p>get(only) — readOnly set(only) — writeOnly</p></blockquote><h4 id="Object-defineProperties"><a href="#Object-defineProperties" class="headerlink" title="Object.defineProperties"></a>Object.defineProperties</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123;</span><br><span class="line">  <span class="string">'property1'</span>: &#123;</span><br><span class="line">    value: <span class="literal">true</span>,</span><br><span class="line">    writable: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'property2'</span>: &#123;</span><br><span class="line">    value: <span class="string">'Hello'</span>,</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// etc. etc.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="读取属性"><a href="#读取属性" class="headerlink" title="读取属性"></a>读取属性</h3><h4 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor"></a>Object.getOwnPropertyDescriptor</h4><blockquote><p>返回指定对象上一个自有属性对应的属性描述符（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）。如果指定的属性存在于对象上，则返回其属性描述符对象（property descriptor），否则返回 undefined 。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o, d;</span><br><span class="line"></span><br><span class="line">o = &#123; <span class="keyword">get</span> foo() &#123; <span class="keyword">return</span> <span class="number">17</span>; &#125; &#125;;</span><br><span class="line">d = <span class="built_in">Object</span>.getOwnPropertyDescriptor(o, <span class="string">"foo"</span>);</span><br><span class="line"><span class="comment">// d &#123;</span></span><br><span class="line"><span class="comment">//   configurable: true,</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   get: /*the getter function*/,</span></span><br><span class="line"><span class="comment">//   set: undefined</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">o = &#123; <span class="attr">bar</span>: <span class="number">42</span> &#125;;</span><br><span class="line">d = <span class="built_in">Object</span>.getOwnPropertyDescriptor(o, <span class="string">"bar"</span>);</span><br><span class="line"><span class="comment">// d &#123;</span></span><br><span class="line"><span class="comment">//   configurable: true,</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   value: 42,</span></span><br><span class="line"><span class="comment">//   writable: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">o = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">"baz"</span>, &#123;</span><br><span class="line">  value: <span class="number">8675309</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line">d = <span class="built_in">Object</span>.getOwnPropertyDescriptor(o, <span class="string">"baz"</span>);</span><br><span class="line"><span class="comment">// d &#123;</span></span><br><span class="line"><span class="comment">//   value: 8675309,</span></span><br><span class="line"><span class="comment">//   writable: false,</span></span><br><span class="line"><span class="comment">//   enumerable: false,</span></span><br><span class="line"><span class="comment">//   configurable: false</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h4 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors"></a>Object.getOwnPropertyDescriptors</h4><blockquote><p>获取一个对象的所有自身属性的描述符。</p></blockquote><p>原型模式中例子理解。</p><h3 id="Create-Object"><a href="#Create-Object" class="headerlink" title="Create Object"></a>Create Object</h3><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><blockquote><p>快速创建多个相似对象</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    obj.name = name;</span><br><span class="line">    obj.age = age;</span><br><span class="line">    obj.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = createPerson(<span class="string">'Tadm'</span>, <span class="number">19</span>);</span><br><span class="line">person1.sayName();</span><br><span class="line"><span class="keyword">let</span> person2 = createPerson(<span class="string">'Tadm1'</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//	缺点：无法确定对象的类型</span></span><br></pre></td></tr></table></figure><h4 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Tadm'</span>, <span class="number">19</span>);</span><br><span class="line">person1.sayName();</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Tadm1'</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">person1.constructor === Person;	<span class="comment">//	true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	也可以通过下列方式</span></span><br><span class="line">Person(<span class="string">'Tadm'</span>, <span class="number">19</span>);</span><br><span class="line"><span class="built_in">window</span>.sayName();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">Person.call(o, <span class="string">'Tadm'</span>, <span class="number">19</span>);</span><br><span class="line">o.sayName();</span><br><span class="line"></span><br><span class="line"><span class="comment">//	缺点: 一样的我们却创建了多个实例</span></span><br><span class="line">person1.sayName === person2.sayName	<span class="comment">//	false</span></span><br></pre></td></tr></table></figure><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">'tadm'</span>;</span><br><span class="line">Person.prototype.age = <span class="number">20</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName();</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person1.sayName === person2.sayName;	<span class="comment">//	true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	isPrototypeOf(obj) 方法允许你检查一个对象是否存在于另一个对象的原型链上。</span></span><br><span class="line">    Person.prototype.isPrototypeOf(person1);	<span class="comment">//	true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	Object.getPrototypeOf(obj) 方法返回指定对象的原型（内部[[Prototype]]属性的值）。</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(person1) === Person.prototype;	<span class="comment">//	true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	obj.hasOwnProperty(property) 方法会返回一个布尔值，指示对象自身(实例非原型)属性中是否具有指定的属性（也就是，是否有指定的键）。</span></span><br><span class="line">person1.hasOwnProperty(<span class="string">'name'</span>);	<span class="comment">//	false</span></span><br><span class="line">person1.name = <span class="string">'tadm1'</span>;</span><br><span class="line">person1.hasOwnProperty(<span class="string">'name'</span>); <span class="comment">//	true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(person1,<span class="string">'name'</span>)</span><br><span class="line"><span class="comment">//	&#123;value: "tadm1", writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="comment">//	__proto__: Object</span></span><br><span class="line"></span><br><span class="line">person1.age = <span class="number">19</span>;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(person1);</span><br><span class="line"><span class="comment">//	&#123;name: &#123;…&#125;, age: &#123;…&#125;&#125;</span></span><br><span class="line"><span class="comment">//	name: &#123;value: "tadm1", writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="comment">//	__proto__: Object</span></span><br><span class="line"><span class="comment">//	age: &#123;value: 19, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="comment">//	__proto__: Object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	缺点：原型中的所有属性是被实例共享的，基本类型无碍但是属性为引用类型(比如数组)时，一个实例修改某个属性时则会导致原型上的改属性也被修改，但可能往往另一个实例的该属性并不想要此变化。</span></span><br></pre></td></tr></table></figure><h4 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h4><blockquote><p>非常常用，推荐！</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>,<span class="string">'green'</span>,<span class="string">'blue'</span>]</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    sayName: function()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Tadm'</span>, <span class="number">19</span>);</span><br><span class="line">person1.name = <span class="string">'liu'</span>;</span><br><span class="line">person1.sayName();	<span class="comment">//	liu</span></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Tadm1'</span>, <span class="number">20</span>);</span><br><span class="line">person2.sayName();	<span class="comment">//	Tadm1</span></span><br><span class="line"></span><br><span class="line">person1.age === person2.age;	<span class="comment">//	false</span></span><br><span class="line">person1.sayName === person2.sayName;	<span class="comment">//	true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	注意，当我们在用对象字面量重写 prototype 时会断掉实例和原型的联系,此时实例仍是引用之前的原型</span></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    sayName: function()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'override'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person1.sayName()	<span class="comment">//	liu</span></span><br><span class="line">Person.prototype.sayName()	<span class="comment">//	override</span></span><br></pre></td></tr></table></figure><h4 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>该模式时不能使用字面量形式重写原型，同样会切断实例和原型的联系。</p></blockquote><h4 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h4><blockquote><p>不推荐，了解即可</p></blockquote><h4 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.sayName() = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = Person(<span class="string">'Tadm'</span>, <span class="number">19</span>);</span><br><span class="line">person1.sayName();	<span class="comment">//	Tadm</span></span><br></pre></td></tr></table></figure><blockquote><p>此时没有this 和 new 操作，只能通过 sayName() 来访问 name,为对象的数据成员提供了一个’稳妥’的环境。</p><p>而且同寄生构造函数模式一样，创建的对象与构造函数或者其原型没有关系。</p></blockquote><h3 id="Extends"><a href="#Extends" class="headerlink" title="Extends"></a>Extends</h3><h4 id="组合继承-常用"><a href="#组合继承-常用" class="headerlink" title="组合继承(常用)"></a>组合继承(常用)</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>,<span class="string">'green'</span>,<span class="string">'blue'</span>]</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name)	<span class="comment">//	第二次</span></span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()	<span class="comment">//	第一次</span></span><br><span class="line">SubType.prototype.constructor = SubType</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">'tadm'</span>, <span class="number">19</span>);</span><br><span class="line">instance1.colors.push(<span class="string">'auqa'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.name, instance1.age, instance1.colors);</span><br><span class="line"><span class="comment">//	tadm 19 (4) ["red", "green", "blue", "auqa"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">'tadm1'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.name, instance2.age, instance2.colors);</span><br><span class="line"><span class="comment">//	tadm1 20 (3) ["red", "green", "blue"]</span></span><br></pre></td></tr></table></figure><blockquote><p>缺点：无论什么情况下都会调用两次超类型的构造函数（一次是在创建子类原型时，第二次是子类型构造函数内），这样就会产生不必要的、多余的属性；而且子类型会包含超类型所有的属性。</p></blockquote><h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//	创建一个临时性构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//	将传入对象作为此构造函数原型</span></span><br><span class="line">    F.prototype = o</span><br><span class="line">    <span class="comment">//	返回此临时类型的一个实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">'tadm'</span>,</span><br><span class="line">    age: <span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> anotherPerson1 = object(person)</span><br><span class="line">anotherPerson1.name = <span class="string">'tadm1'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anotherPerson2 = <span class="built_in">Object</span>.create(person, &#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        value: <span class="string">'tadm2'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    age: &#123;</span><br><span class="line">        value: <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>同原型模式一样，引用类型值的属性会被实例所共享。</p></blockquote><h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype = o</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">origin</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> clone = object(origin)</span><br><span class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hi'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">'tadm'</span>,</span><br><span class="line">    age: <span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> anotherPerson = createAnother(person)</span><br><span class="line">anotherPerson.sayHi()	<span class="comment">//	hi</span></span><br></pre></td></tr></table></figure><h4 id="寄生组合式继承-最理想"><a href="#寄生组合式继承-最理想" class="headerlink" title="寄生组合式继承(最理想)"></a>寄生组合式继承(最理想)</h4><blockquote><p>构造函数继承属性，原型链的混成形式继承方法。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype = o</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//	创建超类型原型的副本</span></span><br><span class="line">    <span class="keyword">let</span> prototype = object(superType.prototype)</span><br><span class="line">    <span class="comment">//	为副本添加 constructor 属性，弥补重写原型而失去默认的该属性</span></span><br><span class="line">    prototype.constructor = subType</span><br><span class="line">    <span class="comment">//	将副本赋值给子类型的原型</span></span><br><span class="line">    subType.prototype = prototype</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>,<span class="string">'green'</span>,<span class="string">'blue'</span>]</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name)</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SubType, SuperType)	<span class="comment">//	一次</span></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类似数组的对象"><a href="#类似数组的对象" class="headerlink" title="类似数组的对象"></a>类似数组的对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">args</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">arguments</span> &#125;</span><br><span class="line"><span class="keyword">var</span> arrayLike = args(<span class="string">'a'</span>, <span class="string">'b'</span>);</span><br><span class="line"></span><br><span class="line">arrayLike[<span class="number">0</span>] <span class="comment">// 'a'</span></span><br><span class="line">arrayLike.length <span class="comment">// 2</span></span><br><span class="line">arrayLike <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DOM元素集</span></span><br><span class="line"><span class="keyword">var</span> elts = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'h3'</span>);</span><br><span class="line">elts.length <span class="comment">// 3</span></span><br><span class="line">elts <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="string">'abc'</span>[<span class="number">1</span>] <span class="comment">// 'b'</span></span><br><span class="line"><span class="string">'abc'</span>.length <span class="comment">// 3</span></span><br><span class="line"><span class="string">'abc'</span> <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>​ 如果我们想要将其变为真正的数组：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(arrayLike);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">value, index</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index + <span class="string">' : '</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Array</span>.prototype.forEach.call(arrayLike, print);</span><br></pre></td></tr></table></figure><h3 id="More"><a href="#More" class="headerlink" title="More"></a>More</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noopener">ObjectFunction</a></p><h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><h3 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h3><blockquote><p> JavaScript 语言中称函数为第一等公民（函数与其他数据类型地位平等）</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//	声明定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	函数表达式</span></span><br><span class="line"><span class="keyword">var</span> print = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s);</span><br><span class="line">&#125;;	<span class="comment">//	此处需要分号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	通过Function构造函数(不推荐)</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(</span><br><span class="line">  <span class="string">'x'</span>,</span><br><span class="line">  <span class="string">'y'</span>,</span><br><span class="line">  <span class="string">'return x + y'</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>函数重复声明定义时会进行重载覆盖操作</p></blockquote><p>声明定义方式与函数表达式方式区别：</p><ul><li><strong>声明定义</strong>可在<strong>声明前调用</strong>。因为此时函数名类似于变量名（变量提升），整个函数则会被提升到代码头部。然而函数表达式（赋值）方式则不能在声明前调用，会抛出错误。</li><li>但是采用<code>function</code>命令和<code>var</code>赋值语句声明同一个函数，由于存在<strong>函数提升</strong>，最后会采用<code>var</code><strong>赋值</strong>语句的定义。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(f.name);	<span class="comment">//	获取参数函数的名字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(myFunc) 	<span class="comment">// myFunc</span></span><br><span class="line">test.length		<span class="comment">//	返回函数预期传入的参数个数，即函数定义之中的参数个数</span></span><br></pre></td></tr></table></figure><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><ul><li><p>全局作用域</p></li><li><p>函数作用域（外部不能访问读取修改）</p><ul><li><p>与全局作用域一样，函数作用域内部也会产生“变量提升”现象。<code>var</code>命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。</p></li><li><p>优先读取所在作用域变量，若没有才会沿上一层查找。（作用域链）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = x - <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    tmp = x - <span class="number">100</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>块级作用域（ES6）</p></li></ul><h3 id="闭包-重点"><a href="#闭包-重点" class="headerlink" title="闭包 (重点)"></a>闭包 (重点)</h3><p>因为<code>JS</code>存在”链式作用域”，所以子对象会层级的向上寻找所需变量，同时父对象所有的变量对其子对象是可见的（很好的理解全局作用域）。</p><blockquote><p>能够读取其他函数<strong>内部变量</strong>的<strong>函数</strong>（定义在一个函数内部的函数）</p></blockquote><p>用途：</p><ul><li><p>可以读取函数内部的变量</p></li><li><p>让这些变量始终保持在内存中（JS 有内存回收机制）,使得它诞生环境一直存在</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIncrementor</span>(<span class="params">start</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> start++;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inc = createIncrementor(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">inc() <span class="comment">// 5</span></span><br><span class="line">inc() <span class="comment">// 6</span></span><br><span class="line">inc() <span class="comment">// 7</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意，外层函数<strong>每次运行</strong>，都会生成一个<strong>新的闭包</strong>，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。</p></blockquote><h3 id="立即调用的函数表达式（IIFE）"><a href="#立即调用的函数表达式（IIFE）" class="headerlink" title="立即调用的函数表达式（IIFE）"></a>立即调用的函数表达式（IIFE）</h3><blockquote><p>自调用匿名函数</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;());</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;)();</span><br></pre></td></tr></table></figure><p>用途：</p><ul><li>避免污染全局变量</li><li>IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量</li></ul><h3 id="eval-不常用，了解"><a href="#eval-不常用，了解" class="headerlink" title="eval (不常用，了解)"></a>eval (不常用，了解)</h3><blockquote><p>接受一个字符串作为参数，并将这个字符串当作语句执行</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">'var a = 1;'</span>);</span><br><span class="line">a 	<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="number">123</span>) 	<span class="comment">// 123,非字符串时，原样返回</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	eval没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值</span></span><br><span class="line"><span class="comment">//	为了防止这种风险，JavaScript 规定，使用严格模式时，eval内部声明的变量，不会影响到外部作用域</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">'var foo = 123'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(foo);  <span class="comment">// ReferenceError: foo is not defined</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>	<span class="comment">// "number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>		<span class="comment">// "boolean"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'tadm'</span>	<span class="comment">// "boolean"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>	<span class="comment">//	"undefined"</span></span><br><span class="line"><span class="keyword">typeof</span> 未声明或者未初始化的变量		<span class="comment">//	"undefined"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>		<span class="comment">// "object" (空对象引用)</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">window</span>	<span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;		<span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> []		<span class="comment">// "object"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"my"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typeof</span> f		<span class="comment">// "function"</span></span><br></pre></td></tr></table></figure><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><blockquote><p>返回一个布尔值，表示对象是否为某个构造函数的实例（检查整个原型链）;只能用于对象，不适用（七种）原始类型的值.</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> Vehicle();</span><br><span class="line">v <span class="keyword">instanceof</span> Vehicle <span class="comment">// true</span></span><br><span class="line"><span class="comment">//	Vehicle.prototype.isPrototypeOf(v)</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span></span><br><span class="line"><span class="comment">//	false</span></span><br><span class="line"><span class="literal">undefined</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span></span><br><span class="line"><span class="comment">//	false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> y = &#123;&#125;;</span><br><span class="line">x <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br><span class="line">x <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">y <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">y <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// false</span></span><br><span class="line"><span class="comment">//	这样可以区分数组和对象的类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">'hello'</span>;</span><br><span class="line">s <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="基本结构体"><a href="#基本结构体" class="headerlink" title="基本结构体"></a>基本结构体</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a === <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> n = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m !== <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> (n === <span class="number">2</span>) <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line"><span class="comment">//	打印 hello 因为 else 始终和距离最近的相匹配</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fruit = <span class="string">'apple'</span></span><br><span class="line"><span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"banana"</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"apple"</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(condition) ? 表达式<span class="number">1</span> : 表达式<span class="number">2</span></span><br><span class="line"><span class="comment">//	true to 1	false to 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= <span class="number">6</span>; i++)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(condition)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">while</span>(condition)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//	break语句用于跳出代码块或循环</span></span><br><span class="line"><span class="comment">//	continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环</span></span><br><span class="line">    </span><br><span class="line">top:</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (i === <span class="number">1</span> &amp;&amp; j === <span class="number">1</span>) <span class="keyword">break</span> top;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'i='</span> + i + <span class="string">', j='</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// i=0, j=0</span></span><br><span class="line"><span class="comment">// i=0, j=1</span></span><br><span class="line"><span class="comment">// i=0, j=2</span></span><br><span class="line"><span class="comment">// i=1, j=0</span></span><br></pre></td></tr></table></figure><h1 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h1><h1 id="变量、作用域、内存"><a href="#变量、作用域、内存" class="headerlink" title="变量、作用域、内存"></a>变量、作用域、内存</h1><h2 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ul><li>会在变量对象上创建一个新值，再将其复制到为新变量分配的位置上。因此我们操作新变量时不会影响原来的变量。</li></ul><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><ul><li>同基本类型原理一样，不过此值是一个指向变量值存储在堆（基本类型放于栈内存，Object等放于堆内存）中的地址的指针。此时他们两个就指向同一个内存地址，因此会互相影响。</li></ul><h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><blockquote><p><strong>按值传递</strong>（将函数外的值传入函数内同变量（基本类型与引用类型）间的复制一样）</p></blockquote><p>一般我们可以在函数内通过 <code>arguments</code> <strong>对象</strong>来访问传递到函数的参数数组（arguments[0,1,…]），通过<code>arguments.length</code> 来获取参数个数。</p><h2 id="类型检测-1"><a href="#类型检测-1" class="headerlink" title="类型检测"></a>类型检测</h2><ul><li>typeof</li><li>instanceof</li></ul><h2 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h2><blockquote><p>执行环境定义了变量或者函数有权访问的其他数据，决定了他们各自的行为。</p><p>代码在一个环境中执行时，会创建变量对象的一个作用域链。其用途是保证对执行环境有权访问的变量和函数的有序访问。</p></blockquote><p><img src="C:%5CUsers%5C28731%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200410092522058.png" alt="image-20200410092522058"></p><h2 id="没有块级作用域"><a href="#没有块级作用域" class="headerlink" title="没有块级作用域"></a>没有块级作用域</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> color = <span class="string">'aqua'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(color)	<span class="comment">//	aqua</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">    doSth(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i)	<span class="comment">//	i=10</span></span><br></pre></td></tr></table></figure><p>使用 var 声明的变量会自动被添加到最接近的环境中。</p><ul><li>函数内部 —- 函数的局部环境</li><li>with 语句 — 函数环境</li><li>未使用 var 声明 — 该变量自动添加到全局环境</li></ul><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><ul><li><p>标记清除</p><ul><li>进入环境 — 不回收</li><li>离开环境 — 回收</li></ul></li><li><p>引用计数（被引用的次数）</p></li><li><p>window.CollectGarBage()</p></li></ul><h2 id="解除引用"><a href="#解除引用" class="headerlink" title="解除引用"></a>解除引用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">2</span></span><br><span class="line">doSth()</span><br><span class="line">a = <span class="literal">null</span> <span class="comment">//	解除引用</span></span><br></pre></td></tr></table></figure><blockquote><p>解除引用并不是自动回收该值所占用的内存，而是让该值脱离执行环境，以便垃圾回收器下次运行时将其回收。</p></blockquote><h1 id="引用类型-1"><a href="#引用类型-1" class="headerlink" title="引用类型"></a>引用类型</h1><blockquote><p>后续持续更新，敬请期待！</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://wangdoc.com/javascript/index.html" target="_blank" rel="noopener">JavaScript</a><br><a href="https://es6.ruanyifeng.com/" target="_blank" rel="noopener">ES6</a></p></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author:</span> <span class="post-copyright-info"><a href="mailto:undefined">𝓣𝓪𝓭𝓶</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link:</span> <span class="post-copyright-info"><a href="https://liuhongwei3.github.io/2020/03/21/JavaScriptNotes/">https://liuhongwei3.github.io/2020/03/21/JavaScriptNotes/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice:</span> <span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/03/24/alibaba%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E5%B8%B8%E7%94%A8%E8%A7%84%E8%8C%83/"><i class="fa fa-chevron-left"></i> <span>alibaba开发手册常用规范</span></a></div><div class="next-post pull-right"><a href="/2020/02/21/NodeStudy/"><span>NodeStudy</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image:url(https://i.loli.net/2020/02/28/2OPSFfaL73QIizV.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 &nbsp;<i class="fa fa-heart" aria-hidden="true" id="myheart"></i>&nbsp; <a href="https://liuhongwei3.github.io/" target="_blank">𝓣𝓪𝓭𝓶</a></div><div class="framework-info"><span>Driven -</span> <a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme -</span> <a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="footer_custom_text">Hi,Welcome to my blog,maybe you can find more!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-eye"></i>本篇已阅读次数：<span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/heart.js?version=1.7.0"></script><script src="/js/typed.js?version=1.7.0"></script><script src="/js/google.js?version=1.7.0"></script><script>/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)&&($("#nav").addClass("is-mobile"),$("footer").addClass("is-mobile"),$("#top-container").addClass("is-mobile"))</script></body></html>